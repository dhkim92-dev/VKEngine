#version 450
layout(local_size_x = 4, local_size_y=4, local_size_z=1) in;

layout(binding = 0, rgba8) uniform readonly image2D input_image;
layout(binding = 1, rgba8) uniform image2D result_image;

const float kernel[9] = {
	1/16.f, 1/8.f, 1/16.f,
	1/8.f, 1/4.f, 1/8.f,
	1/16.f, 1/8.f, 1/16.f
};

shared vec4 lmem[36];

vec4 conv(ivec2 lid){
	vec4 res = vec4(0.0f);

	for(uint i = 0 ; i < 3 ; i++){
		for(uint j = 0 ; j < 3 ; j++){
			res.r +=  ( lmem[ (lid.y + i ) * 6 + (lid.x + j )].r  *  kernel[i * 3 + j] );
			res.g +=  ( lmem[ (lid.y + i ) * 6 + (lid.x + j )].g  *  kernel[i * 3 + j] );
			res.b +=  ( lmem[ (lid.y + i ) * 6 + (lid.x + j )].b  *  kernel[i * 3 + j] );
		}
	}
	res.a = 1.0f;
	return res;
}


void main(){
	ivec2 wg_id = ivec2(gl_WorkGroupID.xy);
	ivec2 l_id = ivec2(gl_LocalInvocationID.xy);
	ivec2 offset = ivec2(wg_id.x * 4, wg_id.y * 4) + l_id;
	
	for(int i = -1 ; i < 2 ; i++){
		for(int j = -1 ; j < 2 ; j++){
			int lidx = (i + 1 + l_id.y)*6 + (j + 1 + l_id.x);
			lmem[lidx] = imageLoad(input_image, offset - ivec2(j,i) );
		}
	}

	barrier();
	memoryBarrierShared();
	imageStore(result_image, offset, conv((l_id)) );
}